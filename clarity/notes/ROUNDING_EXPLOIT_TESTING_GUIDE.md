# Rounding Exploit Testing Guide

## Purpose

This guide is for white-hat hackers and security researchers testing for rounding-based exploits in DLMM contracts. After two audits, the primary remaining concern is **rounding differences** between integer math (contract) and float math (ideal) that could be exploited.

## Core Testing Philosophy

**Pretend you are a world-class white-hat hacker** looking to provide a proof-of-concept exploit that:
1. Can be reproduced reliably
2. Occurs because of differences between integer rounding and float math
3. Allows unfair value extraction from the pool
4. Can be compounded over multiple transactions

## Critical Functions to Test

Focus on the **5 core permissionless functions** in `dlmm-core-v-1-1`:

1. **`swap-x-for-y`** - Swap X tokens for Y tokens (active bin only)
2. **`swap-y-for-x`** - Swap Y tokens for X tokens (active bin only)
3. **`add-liquidity`** - Add liquidity to a specific bin
4. **`withdraw-liquidity`** - Remove liquidity from a bin
5. **`move-liquidity`** - Move liquidity between bins

### Important Distinctions

#### Active Bin Swaps vs Multi-Bin Swaps

- **`swap-x-for-y` / `swap-y-for-x`** (dlmm-core):
  - **Only work on the active bin**
  - Direct swaps within a single bin
  - Use these for testing active bin rounding behavior

- **Swap Router** (`dlmm-swap-router-v-1-1`):
  - Allows swaps across **multiple bins** in a single transaction
  - Can traverse multiple bins if constructed properly
  - Use for testing bin coverage and multi-bin rounding accumulation
  - More complex but allows broader coverage

- **Liquidity Router** (`dlmm-liquidity-router-v-1-1`):
  - Handles liquidity operations across multiple bins/pools
  - Can add/remove liquidity across multiple positions
  - Use for testing liquidity operation rounding across bins

**For initial exploit testing**: Focus on the 5 core functions first. Multi-bin swaps via routers are important for coverage but secondary to proving basic rounding exploits don't exist.

## Rounding Exploit Testing Strategy

### The Core Question

**Can integer rounding differences be exploited to extract more value than float math suggests?**

### Testing Approach

1. **Calculate Expected Output (Float Math)**
   - Use ideal float arithmetic to calculate what the output *should* be
   - This is your baseline for "fair" behavior

2. **Get Actual Output (Integer Math)**
   - Execute the contract function
   - Record the actual output from the contract

3. **Compare and Analyze**
   - If `actualOutput > expectedFloat`: **User-favored bias** (potential exploit)
   - If `actualOutput < expectedFloat`: Pool-favored bias (less concerning)
   - Track cumulative bias over multiple transactions

4. **Test Compounding**
   - Can small rounding differences compound over many transactions?
   - Test with zero fees first (worst case)
   - Then test with normal fees

### Key Test Scenarios

#### Scenario 1: Zero-Fee Exploit
- Create pool with all fees set to zero
- Perform many small swaps
- Measure if user receives more than float math suggests
- Test if repeated small swaps can drain a bin

#### Scenario 2: Cumulative Rounding Bias
- Perform 1000+ transactions
- Track cumulative rounding differences
- Verify bias doesn't compound unboundedly
- Check if pool value leaks over time

#### Scenario 3: Edge Cases
- Very small amounts (minimum swap amounts)
- Very large amounts (near bin capacity)
- Boundary conditions (exactly at bin limits)
- Fee boundary conditions (0%, very low %, normal %)

## Implementation Details

### Float Math Calculation

For swaps, the contract uses:
- Integer division (rounds down)
- Ceiling rounding for max-amount calculations: `(a + b - 1) / b`
- Multiple caps and adjustments

Your float calculation should:
- Use JavaScript `Number` type for intermediate calculations
- Apply the same formulas as the contract
- Convert final result to `BigInt` for comparison
- Account for all fees, caps, and adjustments

### Reference Implementation

See `tests/dlmm-core-comprehensive-fuzz.test.ts`:
- Lines 1274-1540: Swap rounding checks (reference pattern)
- Lines 1853-1893: Add-liquidity (needs float comparison)
- Lines 1894-1922: Withdraw-liquidity (needs float comparison)
- After line 1922: Move-liquidity (needs to be added)

### Logging and Analysis

- Log **all** rounding differences, not just violations
- Track bias direction (user-favored vs pool-favored)
- Calculate cumulative impact
- Generate analysis reports

## Success Criteria

An exploit exists if:
1. **User receives more than float math suggests** (`actualOutput > expectedFloat`)
2. **This can be repeated** to extract value
3. **It compounds** over multiple transactions
4. **It's reproducible** with specific inputs

**CRITICAL**: The test must **fail immediately** on condition #1, regardless of magnitude. Even 1 extra token is an exploit because:
- It can be repeated millions of times
- Small amounts compound into large value extraction
- Security is binary - either it's secure or it's not

See [lessons-learned/adversarial-exploit-detection.md](./lessons-learned/adversarial-exploit-detection.md) for the adversarial mindset and implementation pattern.

If no such exploit exists:
- Document the maximum rounding difference
- Prove it's bounded
- Show pool value is conserved
- Provide mathematical proof

## Current Status

- ✅ Swaps have full float comparison and bias tracking
- ⏳ Add-liquidity needs float comparison
- ⏳ Withdraw-liquidity needs float comparison
- ⏳ Move-liquidity needs float comparison
- ⏳ Mathematical proof document needed

See `COMPREHENSIVE_PLAN_COORDINATION.md` for current todo status.

## Resources

- **Main Test File**: `tests/dlmm-core-comprehensive-fuzz.test.ts`
- **Zero-Fee Exploit Tests**: `tests/dlmm-core-zero-fee-exploit.test.ts`
- **Analysis Scripts**: `scripts/analyze-*.ts`
- **Coordination File**: `notes/COMPREHENSIVE_PLAN_COORDINATION.md`
- **Lessons Learned**: `notes/lessons-learned/`

