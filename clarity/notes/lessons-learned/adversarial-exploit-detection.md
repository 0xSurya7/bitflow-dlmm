# Adversarial Exploit Detection - Critical Security Lesson

**Date**: 2025-01-27  
**Agent**: Agent 0  
**Context**: Implementing exploit detection for swap rounding checks

## The Core Principle

**Think adversarially**: If a user can receive MORE tokens than float math suggests (even 1 token), this is an exploit that must fail the test immediately, regardless of magnitude.

## Why Tiny Amounts Matter

A hacker will repeat operations to compound small rounding errors into massive exploits:

- **1 token per transaction** Ã— **1 million transactions** = **1 million tokens stolen**
- **0.0001% per transaction** Ã— **repeated operations** = **unbounded value extraction**

**Any user-favored bias is unacceptable**, no matter how small.

## The Problem We Had

The test was only checking if the **absolute difference** exceeded a threshold (>1% or >100 tokens). This meant:

- âŒ User getting 50 extra tokens (0.01%) â†’ **NOT DETECTED** (below threshold)
- âŒ User getting 1 extra token (0.0001%) â†’ **NOT DETECTED** (below threshold)
- âœ… User getting 101 extra tokens (0.02%) â†’ **DETECTED** (above threshold)

This is **wrong** because even 1 extra token is an exploit if it can be repeated.

## The Correct Approach

### Two Separate Checks

1. **CRITICAL EXPLOIT CHECK** (Must Fail Immediately):
   ```typescript
   // If user receives MORE than float math suggests, this is an exploit
   // Fail immediately regardless of magnitude - even 1 token is unacceptable
   if (actualSwappedOut > expectedFloat) {
     // ðŸš¨ EXPLOIT DETECTED - Fail immediately
     issues.push(`ðŸš¨ EXPLOIT DETECTED: User received ${exploitAmount} MORE tokens...`);
   }
   ```

2. **Pool-Favored Check** (Only Flag if Significant):
   ```typescript
   // Pool-favored cases (user gets less) are less critical
   // Only flag if difference is significant (>1% or >100 tokens)
   if (actualSwappedOut < expectedFloat && floatDiff > threshold) {
     // Warning - user got less than expected (less concerning)
   }
   ```

## Key Distinction

| Scenario | User Impact | Severity | Action |
|----------|-------------|----------|--------|
| `actualOutput > expectedFloat` | User gets MORE | **CRITICAL** | **FAIL IMMEDIATELY** (even 1 token) |
| `actualOutput < expectedFloat` | User gets LESS | Warning | Flag only if significant (>1% or >100 tokens) |

## Why This Matters

### Example Attack Scenario

1. Attacker finds a swap that gives 1 extra token (0.0001%)
2. Attacker repeats this swap 1 million times
3. Result: 1 million tokens extracted from the pool
4. Pool value leaks to attacker over time

### The Adversarial Mindset

When testing, ask:
- **"Can a user get MORE than they should?"** â†’ If yes, it's an exploit
- **"Can this be repeated?"** â†’ If yes, small amounts become large
- **"What's the worst case?"** â†’ Assume attacker will maximize repetition

## Implementation Pattern

For all rounding checks, use this pattern:

```typescript
// ========================================================================
// CRITICAL EXPLOIT CHECK: User-favored bias (actualOutput > expectedFloat)
// ========================================================================
// If user receives MORE than float math suggests, this is an exploit
// Fail immediately regardless of magnitude - even 1 token is unacceptable
if (actualOutput > expectedFloat) {
  const exploitAmount = actualOutput - expectedFloat;
  const violation = {
    type: 'rounding_error',
    severity: 'critical', // User-favored bias is always critical
    // ... violation data
  };
  logger.addViolation(violation);
  issues.push(`ðŸš¨ EXPLOIT DETECTED: User received ${exploitAmount} MORE tokens...`);
}

// Pool-favored cases (user gets less) - only flag if significant
if (actualOutput < expectedFloat && floatDiff > threshold) {
  // Warning - less critical
}
```

## Applied To

- âœ… `swap-x-for-y`: Checks if `actualSwappedOut > expectedDyFloat`
- âœ… `swap-y-for-x`: Checks if `actualSwappedOut > expectedDxFloat`
- â³ `add-liquidity`: Should check if `lpReceived > expectedLPFloat`
- â³ `withdraw-liquidity`: Should check if `tokensReceived > expectedTokensFloat`
- â³ `move-liquidity`: Should check for any user-favored bias

## Testing Philosophy

From `ROUNDING_EXPLOIT_TESTING_GUIDE.md`:

> **An exploit exists if:**
> 1. **User receives more than float math suggests** (`actualOutput > expectedFloat`)
> 2. **This can be repeated** to extract value
> 3. **It compounds** over multiple transactions
> 4. **It's reproducible** with specific inputs

The test must fail on condition #1 immediately, regardless of magnitude, because conditions #2 and #3 make even tiny amounts dangerous.

## References

- Test implementation: `tests/dlmm-core-comprehensive-fuzz.test.ts`
  - Lines 1577-1622: `swap-x-for-y` exploit check
  - Lines 1982-2027: `swap-y-for-x` exploit check
- Testing guide: `notes/ROUNDING_EXPLOIT_TESTING_GUIDE.md` (Success Criteria section)
- Progress file: `notes/agent-progress/TODO-verify-swap-rounding.md`

## For Other Agents

When implementing rounding checks for other functions:

1. **Always check for user-favored bias first** (`actualOutput > expectedFloat`)
2. **Fail immediately** - no tolerance, no threshold
3. **Think adversarially** - assume attackers will repeat operations
4. **Separate user-favored from pool-favored** - they have different severity

Remember: **Security is binary** - either it's secure or it's not. There's no "mostly secure" when it comes to value extraction.

