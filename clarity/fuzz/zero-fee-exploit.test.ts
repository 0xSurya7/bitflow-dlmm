import {
  alice,
  deployer,
  dlmmCore,
  sbtcUsdcPool,
  mockSbtcToken,
  mockUsdcToken,
  setupTokens,
  generateBinFactors,
} from "../tests/helpers/helpers";

import { describe, it, expect, beforeEach } from 'vitest';
import { txOk, rovOk } from '@clarigen/test';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ============================================================================
// Constants
// ============================================================================

const FEE_SCALE_BPS = 10000n;
const PRICE_SCALE_BPS = 100000000n;

// ============================================================================
// Types
// ============================================================================

interface SwapResult {
  swapNumber: number;
  direction: 'x-for-y' | 'y-for-x';
  inputAmount: bigint;
  actualOutput: bigint;
  expectedInteger: bigint;
  expectedFloat: bigint;
  userFavored: bigint;
  poolFavored: bigint;
  floatDiff: bigint;
  floatPercentDiff: number;
  poolValueBefore: bigint;
  poolValueAfter: bigint;
  activeBinXBefore: bigint;
  activeBinYBefore: bigint;
  activeBinXAfter: bigint;
  activeBinYAfter: bigint;
}

interface CumulativeResults {
  totalSwaps: number;
  totalUserFavored: bigint;
  totalPoolFavored: bigint;
  totalFloatDiff: bigint;
  maxFloatPercentDiff: number;
  totalTokensExtracted: bigint;
  expectedTokensExtractableFloat: bigint;
  excessExtraction: bigint;
  initialPoolValue: bigint;
  finalPoolValue: bigint;
  poolValueChange: bigint;
  swaps: SwapResult[];
}

interface DrainResult {
  drained: boolean;
  swapsToDrain: number;
  totalTokensExtracted: bigint;
  expectedExtractableFloat: bigint;
  totalUserFavored: bigint;
  totalPoolFavored: bigint;
  excessExtraction: bigint;
  finalBinX: bigint;
  finalBinY: bigint;
  swaps: SwapResult[];
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Create a pool with zero fees
 */
function createPoolWithZeroFees() {
  setupTokens();
  
  // Register bin-step 25 before creating pool
  const binStep = 25n;
  const currentBinSteps = rovOk(dlmmCore.getBinSteps());
  if (!currentBinSteps.includes(binStep)) {
    const factors = generateBinFactors();
    txOk(dlmmCore.addBinStep(binStep, factors), deployer);
  }
  
  // Create pool with all fees set to 0
  txOk(dlmmCore.createPool(
    sbtcUsdcPool.identifier,
    mockSbtcToken.identifier,
    mockUsdcToken.identifier,
    10000000n,    // 0.1 BTC in active bin
    5000000000n,  // 5000 USDC in active bin
    1000n,        // burn amount
    0n, 0n,       // x fees (0% protocol, 0% provider)
    0n, 0n,       // y fees (0% protocol, 0% provider)
    25n,          // bin step (25 basis points)
    900n,         // variable fees cooldown
    false,        // freeze variable fees manager
    null,         // dynamic-config (optional)
    deployer,     // fee address
    "https://bitflow.finance/dlmm", // uri
    true          // status
  ), deployer);
}

/**
 * Set pool fees to specified values
 */
function setPoolFees(
  xProtocolFee: bigint,
  xProviderFee: bigint,
  yProtocolFee: bigint,
  yProviderFee: bigint
) {
  txOk(dlmmCore.setXFees(
    sbtcUsdcPool.identifier,
    xProtocolFee,
    xProviderFee
  ), deployer);
  
  txOk(dlmmCore.setYFees(
    sbtcUsdcPool.identifier,
    yProtocolFee,
    yProviderFee
  ), deployer);
}

/**
 * Get bin price from initial price and bin step using contract function
 */
function getBinPrice(initialPrice: bigint, binStep: bigint, binId: bigint): bigint {
  return rovOk(dlmmCore.getBinPrice(initialPrice, binStep, binId))!;
}

/**
 * Get current pool state
 */
function getPoolState() {
  const poolData = rovOk(sbtcUsdcPool.getPool())!;
  const activeBinId = poolData.activeBinId;
  const unsignedBinId = rovOk(dlmmCore.getUnsignedBinId(activeBinId))!;
  const binBalances = rovOk(sbtcUsdcPool.getBinBalances(unsignedBinId))!;
  
  return {
    activeBinId,
    binXBalance: binBalances.xBalance,
    binYBalance: binBalances.yBalance,
    initialPrice: poolData.initialPrice,
    binStep: poolData.binStep,
  };
}

/**
 * Calculate expected output using ideal float math
 * Accounts for fees if they exist
 * Returns both integer and float calculations for comparison
 */
function calculateExpectedOutput(
  inputAmount: bigint,
  direction: 'x-for-y' | 'y-for-x',
  poolState: ReturnType<typeof getPoolState>,
  hasFees: boolean = false
): { expectedInteger: bigint; expectedFloat: bigint } {
  const binPrice = getBinPrice(poolState.initialPrice, poolState.binStep, poolState.activeBinId);
  
  // Get fees if they exist (for integer calculation)
  let effectiveAmount = inputAmount;
  
  if (hasFees) {
    const poolData = rovOk(sbtcUsdcPool.getPool())!;
    const protocolFee = direction === 'x-for-y' 
      ? Number(poolData.xProtocolFee || 0n)
      : Number(poolData.yProtocolFee || 0n);
    const providerFee = direction === 'x-for-y'
      ? Number(poolData.xProviderFee || 0n)
      : Number(poolData.yProviderFee || 0n);
    const variableFee = direction === 'x-for-y'
      ? Number(poolData.xVariableFee || 0n)
      : Number(poolData.yVariableFee || 0n);
    
    const swapFeeTotal = protocolFee + providerFee + variableFee;
    if (swapFeeTotal > 0) {
      // Integer math for fees
      const fees = (inputAmount * BigInt(swapFeeTotal)) / FEE_SCALE_BPS;
      effectiveAmount = inputAmount - fees;
    }
  }
  
  if (direction === 'x-for-y') {
    // Contract logic: First calculate max-x-amount (with ceiling rounding in contract, but we use float)
    // max-x-amount = (y-balance * PRICE_SCALE_BPS + bin-price - 1) / bin-price
    // For float math, we don't need the ceiling adjustment
    const maxXAmountFloat = (Number(poolState.binYBalance) * Number(PRICE_SCALE_BPS)) / Number(binPrice);
    
    // Adjust for fees if they exist
    let updatedMaxXAmountFloat = maxXAmountFloat;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const protocolFee = Number(poolData.xProtocolFee || 0n);
      const providerFee = Number(poolData.xProviderFee || 0n);
      const variableFee = Number(poolData.xVariableFee || 0n);
      const swapFeeTotal = protocolFee + providerFee + variableFee;
      if (swapFeeTotal > 0) {
        // updated-max-x-amount = max-x-amount * FEE_SCALE_BPS / (FEE_SCALE_BPS - swap-fee-total)
        updatedMaxXAmountFloat = (maxXAmountFloat * Number(FEE_SCALE_BPS)) / (Number(FEE_SCALE_BPS) - swapFeeTotal);
      }
    }
    
    // Cap input amount
    const actualInputFloat = Math.min(Number(inputAmount), updatedMaxXAmountFloat);
    
    // Get fees for effective amount calculation
    let actualInputEffectiveFloat = actualInputFloat;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const protocolFee = Number(poolData.xProtocolFee || 0n);
      const providerFee = Number(poolData.xProviderFee || 0n);
      const variableFee = Number(poolData.xVariableFee || 0n);
      const swapFeeTotal = protocolFee + providerFee + variableFee;
      if (swapFeeTotal > 0) {
        actualInputEffectiveFloat = actualInputFloat - ((actualInputFloat * swapFeeTotal) / Number(FEE_SCALE_BPS));
      }
    }
    
    // Integer math: dy = (dx * binPrice) / PRICE_SCALE_BPS
    const expectedDyInteger = (effectiveAmount * binPrice) / PRICE_SCALE_BPS;
    const expectedDyIntegerCapped = expectedDyInteger > poolState.binYBalance 
      ? poolState.binYBalance 
      : expectedDyInteger;
    
    // Float math: dy = (dx * binPrice) / PRICE_SCALE_BPS
    const expectedDyFloat = (actualInputEffectiveFloat * Number(binPrice)) / Number(PRICE_SCALE_BPS);
    const expectedDyFloatCapped = Math.min(expectedDyFloat, Number(poolState.binYBalance));
    const expectedDyFloatBigInt = BigInt(Math.floor(expectedDyFloatCapped));
    
    return {
      expectedInteger: expectedDyIntegerCapped,
      expectedFloat: expectedDyFloatBigInt,
    };
  } else {
    // Contract logic: First calculate max-y-amount (with ceiling rounding in contract, but we use float)
    // max-y-amount = (x-balance * bin-price + PRICE_SCALE_BPS - 1) / PRICE_SCALE_BPS
    // For float math, we don't need the ceiling adjustment
    const maxYAmountFloat = (Number(poolState.binXBalance) * Number(binPrice)) / Number(PRICE_SCALE_BPS);
    
    // Adjust for fees if they exist
    let updatedMaxYAmountFloat = maxYAmountFloat;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const protocolFee = Number(poolData.yProtocolFee || 0n);
      const providerFee = Number(poolData.yProviderFee || 0n);
      const variableFee = Number(poolData.yVariableFee || 0n);
      const swapFeeTotal = protocolFee + providerFee + variableFee;
      if (swapFeeTotal > 0) {
        // updated-max-y-amount = max-y-amount * FEE_SCALE_BPS / (FEE_SCALE_BPS - swap-fee-total)
        updatedMaxYAmountFloat = (maxYAmountFloat * Number(FEE_SCALE_BPS)) / (Number(FEE_SCALE_BPS) - swapFeeTotal);
      }
    }
    
    // Cap input amount
    const actualInputFloat = Math.min(Number(inputAmount), updatedMaxYAmountFloat);
    
    // Get fees for effective amount calculation
    let actualInputEffectiveFloat = actualInputFloat;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const protocolFee = Number(poolData.yProtocolFee || 0n);
      const providerFee = Number(poolData.yProviderFee || 0n);
      const variableFee = Number(poolData.yVariableFee || 0n);
      const swapFeeTotal = protocolFee + providerFee + variableFee;
      if (swapFeeTotal > 0) {
        actualInputEffectiveFloat = actualInputFloat - ((actualInputFloat * swapFeeTotal) / Number(FEE_SCALE_BPS));
      }
    }
    
    // Integer math: dx = (dy * PRICE_SCALE_BPS) / binPrice
    const expectedDxInteger = (effectiveAmount * PRICE_SCALE_BPS) / binPrice;
    const expectedDxIntegerCapped = expectedDxInteger > poolState.binXBalance
      ? poolState.binXBalance
      : expectedDxInteger;
    
    // Float math: dx = (dy * PRICE_SCALE_BPS) / binPrice
    const expectedDxFloat = (actualInputEffectiveFloat * Number(PRICE_SCALE_BPS)) / Number(binPrice);
    const expectedDxFloatCapped = Math.min(expectedDxFloat, Number(poolState.binXBalance));
    const expectedDxFloatBigInt = BigInt(Math.floor(expectedDxFloatCapped));
    
    return {
      expectedInteger: expectedDxIntegerCapped,
      expectedFloat: expectedDxFloatBigInt,
    };
  }
}

/**
 * Calculate pool value in Y token terms
 */
function calculatePoolValue(poolState: ReturnType<typeof getPoolState>): bigint {
  const binPrice = getBinPrice(poolState.initialPrice, poolState.binStep, poolState.activeBinId);
  // Pool value = xBalance * price + yBalance (in Y token terms)
  return (poolState.binXBalance * binPrice) / PRICE_SCALE_BPS + poolState.binYBalance;
}

/**
 * Measure rounding difference (absolute difference between actual and expected float)
 * Returns: { userFavored: bigint, poolFavored: bigint, totalDiff: bigint, percentDiff: number }
 */
function measureRoundingDifference(
  actualOutput: bigint,
  expectedFloat: bigint
): { userFavored: bigint; poolFavored: bigint; totalDiff: bigint; percentDiff: number } {
  const diff = actualOutput > expectedFloat 
    ? actualOutput - expectedFloat 
    : expectedFloat - actualOutput;
  
  const userFavored = actualOutput > expectedFloat ? diff : 0n;
  const poolFavored = actualOutput < expectedFloat ? diff : 0n;
  const percentDiff = actualOutput > 0n
    ? (Number(diff) / Number(actualOutput)) * 100
    : 0;
  
  return {
    userFavored,
    poolFavored,
    totalDiff: diff,
    percentDiff,
  };
}

/**
 * Perform a single swap
 */
function performSwap(
  direction: 'x-for-y' | 'y-for-x',
  amount: bigint,
  swapNumber: number,
  hasFees: boolean = false
): SwapResult {
  const beforeState = getPoolState();
  const poolValueBefore = calculatePoolValue(beforeState);
  const expected = calculateExpectedOutput(amount, direction, beforeState, hasFees);
  
  let actualOutput: bigint;
  
  if (direction === 'x-for-y') {
    const result = txOk(dlmmCore.swapXForY(
      sbtcUsdcPool.identifier,
      mockSbtcToken.identifier,
      mockUsdcToken.identifier,
      Number(beforeState.activeBinId),
      amount
    ), alice);
    actualOutput = result.value.out;
  } else {
    const result = txOk(dlmmCore.swapYForX(
      sbtcUsdcPool.identifier,
      mockSbtcToken.identifier,
      mockUsdcToken.identifier,
      Number(beforeState.activeBinId),
      amount
    ), alice);
    actualOutput = result.value.out;
  }
  
  const afterState = getPoolState();
  const poolValueAfter = calculatePoolValue(afterState);
  const rounding = measureRoundingDifference(actualOutput, expected.expectedFloat);
  
  return {
    swapNumber,
    direction,
    inputAmount: amount,
    actualOutput,
    expectedInteger: expected.expectedInteger,
    expectedFloat: expected.expectedFloat,
    userFavored: rounding.userFavored,
    poolFavored: rounding.poolFavored,
    floatDiff: rounding.totalDiff,
    floatPercentDiff: rounding.percentDiff,
    poolValueBefore,
    poolValueAfter,
    activeBinXBefore: beforeState.binXBalance,
    activeBinYBefore: beforeState.binYBalance,
    activeBinXAfter: afterState.binXBalance,
    activeBinYAfter: afterState.binYBalance,
  };
}

/**
 * Perform repeated swaps and track cumulative impact
 */
function performRepeatedSwaps(
  count: number,
  amount: bigint,
  direction: 'x-for-y' | 'y-for-x',
  hasFees: boolean = false
): CumulativeResults {
  const initialState = getPoolState();
  const initialPoolValue = calculatePoolValue(initialState);
  
  const swaps: SwapResult[] = [];
  let totalUserFavored = 0n;
  let totalPoolFavored = 0n;
  let totalFloatDiff = 0n;
  let maxFloatPercentDiff = 0;
  let totalTokensExtracted = 0n;
  let expectedTokensExtractableFloat = 0n;
  
  for (let i = 0; i < count; i++) {
    if ((i + 1) % 10 === 0 || i === 0) {
      const percent = ((i + 1) / count * 100).toFixed(1);
      const barWidth = 30;
      const filled = Math.floor((i + 1) / count * barWidth);
      const empty = barWidth - filled;
      const bar = '█'.repeat(filled) + '░'.repeat(empty);
      process.stdout.write(`\r  Progress: [${bar}] ${percent}% (${i + 1}/${count} swaps)`);
    }
    
    const swapResult = performSwap(direction, amount, i + 1, hasFees);
    swaps.push(swapResult);
    
    totalUserFavored += swapResult.userFavored;
    totalPoolFavored += swapResult.poolFavored;
    totalFloatDiff += swapResult.floatDiff;
    if (swapResult.floatPercentDiff > maxFloatPercentDiff) {
      maxFloatPercentDiff = swapResult.floatPercentDiff;
    }
    totalTokensExtracted += swapResult.actualOutput;
    expectedTokensExtractableFloat += swapResult.expectedFloat;
  }
  
  process.stdout.write('\n'); // New line after progress
  
  const finalState = getPoolState();
  const finalPoolValue = calculatePoolValue(finalState);
  const excessExtraction = totalTokensExtracted > expectedTokensExtractableFloat
    ? totalTokensExtracted - expectedTokensExtractableFloat
    : 0n;
  
  return {
    totalSwaps: count,
    totalUserFavored,
    totalPoolFavored,
    totalFloatDiff,
    maxFloatPercentDiff,
    totalTokensExtracted,
    expectedTokensExtractableFloat,
    excessExtraction,
    initialPoolValue,
    finalPoolValue,
    poolValueChange: finalPoolValue - initialPoolValue,
    swaps,
  };
}

/**
 * Test if active bin can be drained unfairly
 */
function testActiveBinDrain(
  swapAmount: bigint,
  direction: 'x-for-y' | 'y-for-x',
  maxSwaps: number = 1000,
  hasFees: boolean = false
): DrainResult {
  const initialState = getPoolState();
  const swaps: SwapResult[] = [];
  
  let currentState = initialState;
  let swapCount = 0;
  let totalTokensExtracted = 0n;
  let expectedExtractableFloat = 0n;
  let totalUserFavored = 0n;
  let totalPoolFavored = 0n;
  
  while (swapCount < maxSwaps) {
    // Check if bin is drained
    if (direction === 'x-for-y' && currentState.binYBalance === 0n) {
      break;
    }
    if (direction === 'y-for-x' && currentState.binXBalance === 0n) {
      break;
    }
    
    if (swapCount % 100 === 0 || swapCount === 0) {
      const percent = maxSwaps > 0 ? ((swapCount / maxSwaps) * 100).toFixed(1) : '0';
      const barWidth = 30;
      const filled = maxSwaps > 0 ? Math.floor((swapCount / maxSwaps) * barWidth) : 0;
      const empty = barWidth - filled;
      const bar = '█'.repeat(filled) + '░'.repeat(empty);
      process.stdout.write(`\r  Progress: [${bar}] ${percent}% | Swaps: ${swapCount} | X: ${currentState.binXBalance} | Y: ${currentState.binYBalance}`);
    }
    
    const swapResult = performSwap(direction, swapAmount, swapCount + 1, hasFees);
    swaps.push(swapResult);
    
    totalTokensExtracted += swapResult.actualOutput;
    expectedExtractableFloat += swapResult.expectedFloat;
    totalUserFavored += swapResult.userFavored;
    totalPoolFavored += swapResult.poolFavored;
    
    currentState = getPoolState();
    swapCount++;
  }
  
  process.stdout.write('\n'); // New line after progress
  const finalState = getPoolState();
  const drained = (direction === 'x-for-y' && finalState.binYBalance === 0n) ||
                  (direction === 'y-for-x' && finalState.binXBalance === 0n);
  
  const excessExtraction = totalTokensExtracted > expectedExtractableFloat
    ? totalTokensExtracted - expectedExtractableFloat
    : 0n;
  
  return {
    drained,
    swapsToDrain: swapCount,
    totalTokensExtracted,
    expectedExtractableFloat,
    totalUserFavored,
    totalPoolFavored,
    excessExtraction,
    finalBinX: finalState.binXBalance,
    finalBinY: finalState.binYBalance,
    swaps,
  };
}

// ============================================================================
// Test Suite
// ============================================================================

describe('Zero-Fee Rounding Exploit Tests', () => {
  
  beforeEach(async () => {
    // Reset state for each test - setupTestEnvironment handles this
  });
  
  describe('Phase 1: Zero-Fee Tests', () => {
    
    beforeEach(() => {
      createPoolWithZeroFees();
    });
    
    it('Should test if zero-fee repeated small swaps allow unfair token extraction (x-for-y)', async () => {
      const swapAmount = 1000n; // Small swap amount
      const swapCount = 100;
      
      const results = performRepeatedSwaps(swapCount, swapAmount, 'x-for-y', false);
      
      console.log('Zero-Fee X-for-Y Results:');
      console.log(`Total swaps: ${results.totalSwaps}`);
      console.log(`Total user favored: ${results.totalUserFavored}`);
      console.log(`Total pool favored: ${results.totalPoolFavored}`);
      console.log(`Total float diff: ${results.totalFloatDiff}`);
      console.log(`Max float % diff: ${results.maxFloatPercentDiff.toFixed(4)}%`);
      console.log(`Total tokens extracted: ${results.totalTokensExtracted}`);
      console.log(`Expected extractable (float): ${results.expectedTokensExtractableFloat}`);
      console.log(`Excess extraction: ${results.excessExtraction}`);
      console.log(`Pool value change: ${results.poolValueChange}`);
      
      // Log results to file
      const resultsDir = path.join(__dirname, '../logs/fuzz-test-results');
      if (!fs.existsSync(resultsDir)) {
        fs.mkdirSync(resultsDir, { recursive: true });
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = path.join(resultsDir, `zero-fee-exploit-x-for-y-${timestamp}.json`);
      fs.writeFileSync(filename, JSON.stringify(results, (_, v) => typeof v === 'bigint' ? v.toString() : v, 2));
      
      // Test assertion: Check if rounding differences were measured
      expect(results.totalFloatDiff).toBeDefined();
    }, 300000); // 5 minute timeout
    
    it('Should test if zero-fee repeated small swaps allow unfair token extraction (y-for-x)', async () => {
      const swapAmount = 1000n; // Small swap amount
      const swapCount = 100;
      
      console.log('\nRunning zero-fee repeated swaps (y-for-x)...');
      const results = performRepeatedSwaps(swapCount, swapAmount, 'y-for-x', false);
      
      console.log('Zero-Fee Y-for-X Results:');
      console.log(`Total swaps: ${results.totalSwaps}`);
      console.log(`Total user favored: ${results.totalUserFavored}`);
      console.log(`Total pool favored: ${results.totalPoolFavored}`);
      console.log(`Total float diff: ${results.totalFloatDiff}`);
      console.log(`Max float % diff: ${results.maxFloatPercentDiff.toFixed(4)}%`);
      console.log(`Total tokens extracted: ${results.totalTokensExtracted}`);
      console.log(`Expected extractable (float): ${results.expectedTokensExtractableFloat}`);
      console.log(`Excess extraction: ${results.excessExtraction}`);
      console.log(`Pool value change: ${results.poolValueChange}`);
      
      // Log results to file
      const resultsDir = path.join(__dirname, '../logs/fuzz-test-results');
      if (!fs.existsSync(resultsDir)) {
        fs.mkdirSync(resultsDir, { recursive: true });
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = path.join(resultsDir, `zero-fee-exploit-y-for-x-${timestamp}.json`);
      fs.writeFileSync(filename, JSON.stringify(results, (_, v) => typeof v === 'bigint' ? v.toString() : v, 2));
      
      // Test assertion: Check if rounding differences were measured
      expect(results.totalFloatDiff).toBeDefined();
    }, 300000); // 5 minute timeout
    
    it('Should test if zero-fee swaps can drain active bin unfairly (x-for-y)', async () => {
      const swapAmount = 1000n; // Small swap amount
      
      console.log('\nRunning zero-fee bin drain test (x-for-y)...');
      const result = testActiveBinDrain(swapAmount, 'x-for-y', 1000, false);
      
      console.log('Zero-Fee Active Bin Drain (X-for-Y) Results:');
      console.log(`Drained: ${result.drained}`);
      console.log(`Swaps to drain: ${result.swapsToDrain}`);
      console.log(`Total tokens extracted: ${result.totalTokensExtracted}`);
      console.log(`Expected extractable (float): ${result.expectedExtractableFloat}`);
      console.log(`Total user favored: ${result.totalUserFavored}`);
      console.log(`Total pool favored: ${result.totalPoolFavored}`);
      console.log(`Excess extraction: ${result.excessExtraction}`);
      console.log(`Final bin X: ${result.finalBinX}`);
      console.log(`Final bin Y: ${result.finalBinY}`);
      
      // Log results to file
      const resultsDir = path.join(__dirname, '../logs/fuzz-test-results');
      if (!fs.existsSync(resultsDir)) {
        fs.mkdirSync(resultsDir, { recursive: true });
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = path.join(resultsDir, `zero-fee-drain-x-for-y-${timestamp}.json`);
      fs.writeFileSync(filename, JSON.stringify(result, (_, v) => typeof v === 'bigint' ? v.toString() : v, 2));
      
      // Test assertion
      expect(result.drained).toBeDefined();
    }, 600000); // 10 minute timeout for drain test
    
    it('Should test if zero-fee swaps can drain active bin unfairly (y-for-x)', async () => {
      const swapAmount = 1000n; // Small swap amount
      
      console.log('\nRunning zero-fee bin drain test (y-for-x)...');
      const result = testActiveBinDrain(swapAmount, 'y-for-x', 1000, false);
      
      console.log('Zero-Fee Active Bin Drain (Y-for-X) Results:');
      console.log(`Drained: ${result.drained}`);
      console.log(`Swaps to drain: ${result.swapsToDrain}`);
      console.log(`Total tokens extracted: ${result.totalTokensExtracted}`);
      console.log(`Expected extractable (float): ${result.expectedExtractableFloat}`);
      console.log(`Total user favored: ${result.totalUserFavored}`);
      console.log(`Total pool favored: ${result.totalPoolFavored}`);
      console.log(`Excess extraction: ${result.excessExtraction}`);
      console.log(`Final bin X: ${result.finalBinX}`);
      console.log(`Final bin Y: ${result.finalBinY}`);
      
      // Log results to file
      const resultsDir = path.join(__dirname, '../logs/fuzz-test-results');
      if (!fs.existsSync(resultsDir)) {
        fs.mkdirSync(resultsDir, { recursive: true });
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = path.join(resultsDir, `zero-fee-drain-y-for-x-${timestamp}.json`);
      fs.writeFileSync(filename, JSON.stringify(result, (_, v) => typeof v === 'bigint' ? v.toString() : v, 2));
      
      // Test assertion
      expect(result.drained).toBeDefined();
    }, 600000); // 10 minute timeout for drain test
  });
  
  describe('Phase 2: With Fees Tests', () => {
    
    beforeEach(() => {
      createPoolWithZeroFees();
      // Set fees to normal values (0.1% protocol, 0.3% provider = 0.4% total)
      setPoolFees(10n, 30n, 10n, 30n);
    });
    
    it('Should test if fees prevent unfair token extraction (x-for-y)', async () => {
      const swapAmount = 1000n; // Small swap amount
      const swapCount = 100;
      
      console.log('\nRunning with-fees repeated swaps (x-for-y)...');
      const results = performRepeatedSwaps(swapCount, swapAmount, 'x-for-y', true);
      
      console.log('With Fees X-for-Y Results:');
      console.log(`Total swaps: ${results.totalSwaps}`);
      console.log(`Total user favored: ${results.totalUserFavored}`);
      console.log(`Total pool favored: ${results.totalPoolFavored}`);
      console.log(`Total float diff: ${results.totalFloatDiff}`);
      console.log(`Max float % diff: ${results.maxFloatPercentDiff.toFixed(4)}%`);
      console.log(`Total tokens extracted: ${results.totalTokensExtracted}`);
      console.log(`Expected extractable (float): ${results.expectedTokensExtractableFloat}`);
      console.log(`Excess extraction: ${results.excessExtraction}`);
      console.log(`Pool value change: ${results.poolValueChange}`);
      
      // Log results to file
      const resultsDir = path.join(__dirname, '../logs/fuzz-test-results');
      if (!fs.existsSync(resultsDir)) {
        fs.mkdirSync(resultsDir, { recursive: true });
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = path.join(resultsDir, `with-fees-exploit-x-for-y-${timestamp}.json`);
      fs.writeFileSync(filename, JSON.stringify(results, (_, v) => typeof v === 'bigint' ? v.toString() : v, 2));
      
      // Test assertion: Check if rounding differences were measured
      expect(results.totalFloatDiff).toBeDefined();
    }, 300000); // 5 minute timeout
    
    it('Should test if fees prevent unfair token extraction (y-for-x)', async () => {
      const swapAmount = 1000n; // Small swap amount
      const swapCount = 100;
      
      console.log('\nRunning with-fees repeated swaps (y-for-x)...');
      const results = performRepeatedSwaps(swapCount, swapAmount, 'y-for-x', true);
      
      console.log('With Fees Y-for-X Results:');
      console.log(`Total swaps: ${results.totalSwaps}`);
      console.log(`Total user favored: ${results.totalUserFavored}`);
      console.log(`Total pool favored: ${results.totalPoolFavored}`);
      console.log(`Total float diff: ${results.totalFloatDiff}`);
      console.log(`Max float % diff: ${results.maxFloatPercentDiff.toFixed(4)}%`);
      console.log(`Total tokens extracted: ${results.totalTokensExtracted}`);
      console.log(`Expected extractable (float): ${results.expectedTokensExtractableFloat}`);
      console.log(`Excess extraction: ${results.excessExtraction}`);
      console.log(`Pool value change: ${results.poolValueChange}`);
      
      // Log results to file
      const resultsDir = path.join(__dirname, '../logs/fuzz-test-results');
      if (!fs.existsSync(resultsDir)) {
        fs.mkdirSync(resultsDir, { recursive: true });
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = path.join(resultsDir, `with-fees-exploit-y-for-x-${timestamp}.json`);
      fs.writeFileSync(filename, JSON.stringify(results, (_, v) => typeof v === 'bigint' ? v.toString() : v, 2));
      
      // Test assertion: Check if rounding differences were measured
      expect(results.totalFloatDiff).toBeDefined();
    });
    
    it('Should test if fees prevent active bin drain exploit (x-for-y)', async () => {
      const swapAmount = 1000n; // Small swap amount
      
      console.log('\nRunning with-fees bin drain test (x-for-y)...');
      const result = testActiveBinDrain(swapAmount, 'x-for-y', 1000, true);
      
      console.log('With Fees Active Bin Drain (X-for-Y) Results:');
      console.log(`Drained: ${result.drained}`);
      console.log(`Swaps to drain: ${result.swapsToDrain}`);
      console.log(`Total tokens extracted: ${result.totalTokensExtracted}`);
      console.log(`Expected extractable (float): ${result.expectedExtractableFloat}`);
      console.log(`Total user favored: ${result.totalUserFavored}`);
      console.log(`Total pool favored: ${result.totalPoolFavored}`);
      console.log(`Excess extraction: ${result.excessExtraction}`);
      console.log(`Final bin X: ${result.finalBinX}`);
      console.log(`Final bin Y: ${result.finalBinY}`);
      
      // Log results to file
      const resultsDir = path.join(__dirname, '../logs/fuzz-test-results');
      if (!fs.existsSync(resultsDir)) {
        fs.mkdirSync(resultsDir, { recursive: true });
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = path.join(resultsDir, `with-fees-drain-x-for-y-${timestamp}.json`);
      fs.writeFileSync(filename, JSON.stringify(result, (_, v) => typeof v === 'bigint' ? v.toString() : v, 2));
      
      // Test assertion
      expect(result.drained).toBeDefined();
    }, 600000); // 10 minute timeout for drain test
    
    it('Should test if fees prevent active bin drain exploit (y-for-x)', async () => {
      const swapAmount = 1000n; // Small swap amount
      
      console.log('\nRunning with-fees bin drain test (y-for-x)...');
      const result = testActiveBinDrain(swapAmount, 'y-for-x', 1000, true);
      
      console.log('With Fees Active Bin Drain (Y-for-X) Results:');
      console.log(`Drained: ${result.drained}`);
      console.log(`Swaps to drain: ${result.swapsToDrain}`);
      console.log(`Total tokens extracted: ${result.totalTokensExtracted}`);
      console.log(`Expected extractable (float): ${result.expectedExtractableFloat}`);
      console.log(`Total user favored: ${result.totalUserFavored}`);
      console.log(`Total pool favored: ${result.totalPoolFavored}`);
      console.log(`Excess extraction: ${result.excessExtraction}`);
      console.log(`Final bin X: ${result.finalBinX}`);
      console.log(`Final bin X: ${result.finalBinX}`);
      console.log(`Final bin Y: ${result.finalBinY}`);
      
      // Log results to file
      const resultsDir = path.join(__dirname, '../logs/fuzz-test-results');
      if (!fs.existsSync(resultsDir)) {
        fs.mkdirSync(resultsDir, { recursive: true });
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = path.join(resultsDir, `with-fees-drain-y-for-x-${timestamp}.json`);
      fs.writeFileSync(filename, JSON.stringify(result, (_, v) => typeof v === 'bigint' ? v.toString() : v, 2));
      
      // Test assertion
      expect(result.drained).toBeDefined();
    }, 600000); // 10 minute timeout for drain test
  });
});

