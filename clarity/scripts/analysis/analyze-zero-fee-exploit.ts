#!/usr/bin/env node
/**
 * Analyze zero-fee exploit test results
 * Detects ANY instance where actualOutput > expectedFloat (unfair extraction)
 * Even tiny amounts are flagged because they can be repeated millions of times
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface SwapResult {
  swapNumber: number;
  direction: 'x-for-y' | 'y-for-x';
  inputAmount: string;
  actualOutput: string;
  expectedInteger: string;
  expectedFloat: string;
  userFavored: string;
  poolFavored: string;
  floatDiff: string;
  floatPercentDiff: number;
}

interface CumulativeResults {
  totalSwaps: number;
  totalUserFavored: string;
  totalPoolFavored: string;
  totalFloatDiff: string;
  maxFloatPercentDiff: number;
  totalTokensExtracted: string;
  expectedTokensExtractableFloat: string;
  excessExtraction: string;
  swaps: SwapResult[];
}

interface DrainResult {
  drained: boolean;
  swapsToDrain: number;
  totalTokensExtracted: string;
  expectedExtractableFloat: string;
  totalUserFavored: string;
  totalPoolFavored: string;
  excessExtraction: string;
  swaps: SwapResult[];
}

function analyzeUnfairExtraction(results: CumulativeResults | DrainResult, testName: string) {
  const swaps = results.swaps || [];
  const unfairSwaps = swaps.filter(s => {
    const userFavored = s.userFavored || '0';
    return BigInt(userFavored) > 0n;
  });
  
  console.log(`\n${testName}:`);
  console.log(`  Total swaps: ${swaps.length}`);
  console.log(`  Swaps with unfair extraction (actualOutput > expectedFloat): ${unfairSwaps.length}`);
  
  if (unfairSwaps.length > 0) {
    console.log(`  ⚠️  UNFAIR EXTRACTION DETECTED!`);
    
    const totalUnfair = swaps.reduce((sum, s) => {
      const userFavored = s.userFavored || '0';
      return sum + BigInt(userFavored);
    }, 0n);
    const maxUnfair = swaps.reduce((max, s) => {
      const userFavored = s.userFavored || '0';
      const val = BigInt(userFavored);
      return val > max ? val : max;
    }, 0n);
    const maxPercent = swaps.reduce((max, s) => {
      const userFavored = s.userFavored || '0';
      return userFavored !== '0' ? Math.max(max, s.floatPercentDiff || 0) : max;
    }, 0);
    
    console.log(`  Total unfair extraction: ${totalUnfair} tokens`);
    console.log(`  Max unfair extraction per swap: ${maxUnfair} tokens`);
    console.log(`  Max unfair % per swap: ${maxPercent.toFixed(6)}%`);
    
    // Show worst cases
    const worstCases = [...unfairSwaps]
      .sort((a, b) => Number(BigInt(b.userFavored) - BigInt(a.userFavored)))
      .slice(0, 5);
    
    console.log(`  Worst cases:`);
    worstCases.forEach((s, i) => {
      const userFavored = s.userFavored || '0';
      const percentDiff = s.floatPercentDiff || 0;
      const expectedFloat = s.expectedFloat || s.expectedOutput || '0';
      console.log(`    ${i + 1}. Swap #${s.swapNumber} (${s.direction}):`);
      console.log(`       Input: ${s.inputAmount}, Actual: ${s.actualOutput}, Expected (float): ${expectedFloat}`);
      console.log(`       Unfair extraction: ${userFavored} tokens (${percentDiff.toFixed(6)}%)`);
    });
    
    // Calculate theoretical maximum if repeated
    if (maxUnfair > 0n) {
      const theoreticalMax = maxUnfair * 10000000n; // 10 million repeats
      console.log(`  ⚠️  Theoretical max if repeated 10M times: ${theoreticalMax} tokens`);
    }
    
    return true;
  } else {
    console.log(`  ✅ No unfair extraction detected`);
    return false;
  }
}

function main() {
  const resultsDir = path.join(__dirname, '../logs/fuzz-test-results');
  
  if (!fs.existsSync(resultsDir)) {
    console.log('Results directory does not exist.');
    return;
  }
  
  const files = fs.readdirSync(resultsDir)
    .filter(f => f.endsWith('.json') && (f.includes('zero-fee-exploit') || f.includes('with-fees-exploit') || f.includes('zero-fee-drain') || f.includes('with-fees-drain')))
    .sort();
  
  if (files.length === 0) {
    console.log('No exploit test result files found.');
    return;
  }
  
  console.log('Zero-Fee Exploit Analysis');
  console.log('='.repeat(80));
  console.log('\nPurpose: Detect ANY instance where actualOutput > expectedFloat');
  console.log('Even tiny amounts are flagged because they can be repeated millions of times.');
  console.log('='.repeat(80));
  
  // Load all results
  const zeroFeeXForY = files.find(f => f.includes('zero-fee-exploit-x-for-y'));
  const zeroFeeYForX = files.find(f => f.includes('zero-fee-exploit-y-for-x'));
  const withFeesXForY = files.find(f => f.includes('with-fees-exploit-x-for-y'));
  const withFeesYForX = files.find(f => f.includes('with-fees-exploit-y-for-x'));
  const zeroFeeDrainXForY = files.find(f => f.includes('zero-fee-drain-x-for-y'));
  const zeroFeeDrainYForX = files.find(f => f.includes('zero-fee-drain-y-for-x'));
  const withFeesDrainXForY = files.find(f => f.includes('with-fees-drain-x-for-y'));
  const withFeesDrainYForX = files.find(f => f.includes('with-fees-drain-y-for-x'));
  
  let exploitDetected = false;
  
  // Analyze repeated swaps
  console.log('\n=== Repeated Swaps Analysis (100 swaps) ===');
  
  if (zeroFeeXForY) {
    const zeroFee = JSON.parse(fs.readFileSync(path.join(resultsDir, zeroFeeXForY), 'utf-8')) as CumulativeResults;
    if (analyzeUnfairExtraction(zeroFee, 'Zero-Fee X-for-Y')) {
      exploitDetected = true;
    }
  }
  
  if (zeroFeeYForX) {
    const zeroFee = JSON.parse(fs.readFileSync(path.join(resultsDir, zeroFeeYForX), 'utf-8')) as CumulativeResults;
    if (analyzeUnfairExtraction(zeroFee, 'Zero-Fee Y-for-X')) {
      exploitDetected = true;
    }
  }
  
  if (withFeesXForY) {
    const withFees = JSON.parse(fs.readFileSync(path.join(resultsDir, withFeesXForY), 'utf-8')) as CumulativeResults;
    if (analyzeUnfairExtraction(withFees, 'With-Fees X-for-Y')) {
      exploitDetected = true;
    }
  }
  
  if (withFeesYForX) {
    const withFees = JSON.parse(fs.readFileSync(path.join(resultsDir, withFeesYForX), 'utf-8')) as CumulativeResults;
    if (analyzeUnfairExtraction(withFees, 'With-Fees Y-for-X')) {
      exploitDetected = true;
    }
  }
  
  // Analyze bin drain
  console.log('\n=== Active Bin Drain Analysis (up to 10,000 swaps) ===');
  
  if (zeroFeeDrainXForY) {
    const zeroFee = JSON.parse(fs.readFileSync(path.join(resultsDir, zeroFeeDrainXForY), 'utf-8')) as DrainResult;
    if (analyzeUnfairExtraction(zeroFee, 'Zero-Fee Drain X-for-Y')) {
      exploitDetected = true;
    }
  }
  
  if (zeroFeeDrainYForX) {
    const zeroFee = JSON.parse(fs.readFileSync(path.join(resultsDir, zeroFeeDrainYForX), 'utf-8')) as DrainResult;
    if (analyzeUnfairExtraction(zeroFee, 'Zero-Fee Drain Y-for-X')) {
      exploitDetected = true;
    }
  }
  
  if (withFeesDrainXForY) {
    const withFees = JSON.parse(fs.readFileSync(path.join(resultsDir, withFeesDrainXForY), 'utf-8')) as DrainResult;
    if (analyzeUnfairExtraction(withFees, 'With-Fees Drain X-for-Y')) {
      exploitDetected = true;
    }
  }
  
  if (withFeesDrainYForX) {
    const withFees = JSON.parse(fs.readFileSync(path.join(resultsDir, withFeesDrainYForX), 'utf-8')) as DrainResult;
    if (analyzeUnfairExtraction(withFees, 'With-Fees Drain Y-for-X')) {
      exploitDetected = true;
    }
  }
  
  // Summary
  console.log('\n' + '='.repeat(80));
  console.log('=== Summary ===');
  console.log('='.repeat(80));
  
  if (exploitDetected) {
    console.log('\n⚠️  EXPLOIT DETECTED: Unfair extraction found!');
    console.log('\nUsers are receiving MORE tokens than float math would suggest.');
    console.log('This can be repeated many times to extract significant value.');
    console.log('\nRecommendation: Investigate the root cause of rounding differences.');
    console.log('Even if the amounts are small, they compound over many transactions.');
  } else {
    console.log('\n✅ NO UNFAIR EXTRACTION DETECTED');
    console.log('\nAll swaps return actualOutput <= expectedFloat (fair or pool-favored).');
    console.log('Rounding differences do not systematically favor users.');
  }
  
  console.log('\n' + '='.repeat(80));
}

main();
